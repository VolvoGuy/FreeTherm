/*	FreeTherm.cs

	Copyright 2008 - 2011 Fred Cooke

	This file is part of the FreeEMS project.

	FreeEMS software is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	FreeEMS software is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with any FreeEMS software.  If not, see <http://www.gnu.org/licenses/>.

	We ask that if you make any changes to this file you send them upstream to us at admin@diyefi.org

	Thank you for choosing FreeEMS to run your engine! */

using Gtk;
using Gdk;
using Glade;
using System;
using System.IO;

namespace FreeTherm {
	
	/// <summary>
	///
	/// FreeTherm is a simple code generator that creates an include file with
	/// an array of temperature values indexable by the ADC input on the target.
	/// 
	/// It does this based on a number of inputs specifying its format and
	/// processing conditions and parameters to ensure maximum flexibility.
	/// 
	/// By Fred Cooke and Shameem Hameed.
	///
	/// See www.diyefi.org for more information on the FreeEMS project.
	///
	/// </summary>
	
	public class FreeTherm {
		
		/* Include all widgets here : */
		#region Glade Widgets
		
		[Glade.Widget]Gtk.Window MainWindow;
		[Glade.Widget]Gtk.AboutDialog AboutFreeThermDialog;
		
		/* These are needed if the event handlers are added locally instead
		 * of defined in the glade file. I think I would prefer that as it
		 * makes it very clear what is happening in the code. Otherwise the
		 * reader is left guessing and cross referencing. */
//		[Glade.Widget]Gtk.ImageMenuItem SaveMenuItem;
//		[Glade.Widget]Gtk.ImageMenuItem AboutMenuItem;
//		[Glade.Widget]Gtk.ImageMenuItem QuitMenuItem;
	
		[Glade.Widget]Gtk.Entry LowDegrees;
		[Glade.Widget]Gtk.Entry LowOhms;
		[Glade.Widget]Gtk.Entry MidDegrees;
		[Glade.Widget]Gtk.Entry MidOhms;
		[Glade.Widget]Gtk.Entry HighDegrees;
		[Glade.Widget]Gtk.Entry HighOhms;
		[Glade.Widget]Gtk.Entry BiasOhms;
		
		[Glade.Widget]Gtk.Entry FileNameEntry;
		[Glade.Widget]Gtk.Entry ArrayNameEntry;
		
		[Glade.Widget]Gtk.Entry ElementsPerLineEntry;
		
		[Glade.Widget]Gtk.TextView CommentView;

		[Glade.Widget]Gtk.RadioButton CelciusIn;
		[Glade.Widget]Gtk.RadioButton KelvinIn;
		[Glade.Widget]Gtk.RadioButton FahrenheitIn;
		[Glade.Widget]Gtk.RadioButton CelciusOut;
		[Glade.Widget]Gtk.RadioButton KelvinOut;
		[Glade.Widget]Gtk.RadioButton FahrenheitOut;

		#endregion

		#region Globals
		
		// Version for output files and display in app
		const string VERSION = "0.6";

		// Constants.
		const double KelvinOffset = 273.15;
		const double FahrenheitOffset = 32;

		enum TempScale{
			Celcius,
			Kelvin,
			Fahrenheit
		}

		// Defaults for common NipponDenso sensor.
		double lowTemp = 0.0;
		double lowRes = 6540.0;

		double midTemp = 25.5;
		double midRes = 2040.0;

		double highTemp = 80.0;
		double highRes = 340.0;

		double biasRes = 2200.0;

		// Defaults for FreeEMS code base.
		string FileName = "IATTransferTable.c";
		
		int elementsPerLine = 16;
		double outputOffset = 0;
		double outputFactor = 100;

		// unfinished stuff double indented.

				/* These need to be generated by the interface event handlers when the display is inited or vice versa */
				int Elements = 1024; // should be part of an enum based on the position of the radiobutton.
				int Ceiling = 65535; // should be part of an enum based on the position of the radiobutton.
				int Floor = 0; // should be part of an enum based on the position of the radiobutton.
				string EOL = "\n"; // should be part of an enum based on the position of the radiobutton.
				string KeyWords = "const "; // rethink the "one per line" idea to reduce processing?
				string DataType = "unsigned short "; // should be part of an enum based on the position of the radiobutton.
				string DataFormat = "00000"; // currently setup for unsigned short.

		// Inited via setting CelciusIn to active = true and KelvinOut to active = true.
		TempScale inputTempScale;
		TempScale outputTempScale;

		// General use.
		double A = 0, B = 0, C = 0;
		bool debug = false; // change this to generate debug output on the console

		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		public static void Main (string[] args) {
			new FreeTherm (args);
		}

		/* Constructor : Builds the structure from the embedded XML and starts the App. */
		public FreeTherm (string[] args) {
			try {
				Application.Init();

				Glade.XML MainXML =  new Glade.XML(null, "FreeTherm.glade", "MainWindow", null);
				MainXML.Autoconnect (this);

				init(); // load all the fields with values from globals for now, but perhaps a user config later?

				Application.Run();
			} catch(Exception e) {
				Console.WriteLine("The application failed to start : " + e.Message + "\nThe StackTrace was : " + e.StackTrace);
			}
		}

		/* Take our defaults from code and install them into the fields of the gui before we display it. */
		/* Note, not doing something like this means the value in memory and displayed could differ. */
		private void init() {
			initFields();
			initButtons();
			initTitle();
		}
		
		/* Install numbers and text into the code. (need to clear them out of the glade file to save space.) */
		private void initFields() {
			BiasOhms.Text = biasRes.ToString();

			LowOhms.Text = lowRes.ToString();
			LowDegrees.Text = lowTemp.ToString();

			MidOhms.Text = midRes.ToString();
			MidDegrees.Text = midTemp.ToString();

			HighOhms.Text = highRes.ToString();
			HighDegrees.Text = highTemp.ToString();

			
			FileNameEntry.Text = FileName;

			ElementsPerLineEntry.Text = elementsPerLine.ToString();
			// TODO the rest!
		}
		
		/* Set the starting positions of the buttons from code to ensure defaults match displayed. */
		private void initButtons() {
			/* Caution: Removing these lines means you MUST provide a value in the variable declaration!
			 * The top item on list is already activated, so no event generated by these
			 * Hence Toggle() call required to ensure our variable is inited internally */
			
			// Make Celcius the default input temperature
			CelciusIn.Active = true;
			CelciusIn.Toggle();
			// Make Kelvin the default output temperature
			KelvinOut.Active = true;
			KelvinOut.Toggle();
		}

		private void initTitle() {
			// Include version in title for quick ID of what a user is using
			MainWindow.Title = "FreeTherm " + VERSION + " DIYEFI.org";
		}

		#region Custom Functions

		// convenient debug writer
		public void dWriteLine(string text) {
			if (debug) {
				Console.WriteLine(text);
			}
		}
					
		/* Calculates the Steinhart and Hart coefficients from 3 data points on the curve of a thermistor. */
		/* Please see http://en.wikipedia.org/wiki/Steinhart-Hart_equation for more information. */
		public void calculateSHCoefficients()
		{
			// Convert input temps to Kelvin
			double lT,mT,hT;

			dWriteLine("lti = " + lowTemp.ToString());
			dWriteLine("mti = " + midTemp.ToString());
			dWriteLine("hti = " + highTemp.ToString());
			
			if (inputTempScale == TempScale.Kelvin) {
				lT = lowTemp;
				mT = midTemp;
				hT = highTemp;
			} else if (inputTempScale == TempScale.Celcius) {
				lT = lowTemp + KelvinOffset;
				mT = midTemp + KelvinOffset;
				hT = highTemp + KelvinOffset;
			} else if (inputTempScale == TempScale.Fahrenheit) {
				lT = (((lowTemp - FahrenheitOffset) * 5) / 9) + KelvinOffset; 
				mT = (((midTemp - FahrenheitOffset) * 5) / 9) + KelvinOffset;
				hT = (((highTemp - FahrenheitOffset) * 5) / 9) + KelvinOffset;
			} else {
				Console.WriteLine("This line should never be printed!");
				return;
			}

			dWriteLine("lto = " + lT.ToString());
			dWriteLine("mto = " + mT.ToString());
			dWriteLine("hto = " + hT.ToString());			
			
			double x1 = 1 / (lT);
			double x2 = 1 / (mT);
			double x3 = 1 / (hT);
			double y1 = Math.Log(lowRes);
			double y2 = Math.Log(midRes);
			double y3 = Math.Log(highRes);
			double y1c = Math.Pow(y1, 3);
			double y2c = Math.Pow(y2, 3);
			double y3c = Math.Pow(y3, 3);

			C = (((y2 - y1) * (x3 - x1)) - ((y3 - y1) * (x2 - x1))) / (((y3c - y1c) * (y2 - y1)) - ((y2c - y1c) * (y3 - y1)));
			B = ((x2 - x1) - (C * (y2c - y1c))) / (y2 - y1);
			A = x1 - B * y1 - C * y1c;
			
			dWriteLine("A = " + A.ToString());
			dWriteLine("B = " + B.ToString());
			dWriteLine("C = " + C.ToString());
		}

		/* A neat way of parsing doubles in a field. */
		public double floatingPointVerify(Entry o, double number) {
			if (o.Text != "") {
				try {
					return Double.Parse(o.Text);
				} catch {
					o.Text = number.ToString(); // This line causes recursion to occur, ensure it is correct.
					return number;
				}
			} else {
				return 0.0;
			}
		}

		/* A neat way of parsing integers in a field. */
		public int integerVerify(Entry o, int number) {
			if (o.Text != "") {
				try {
					return int.Parse(o.Text);
				} catch {
					o.Text = number.ToString(); // This line causes recursion to occur, ensure it is correct.
					return number;
				}
			} else {
				return 0;
			}
		}

		#endregion

		// Connect the Signals defined in Glade

		#region Event handlers

		public void OnMainWindowDeleteEvent(object o, DeleteEventArgs args) {
			Application.Quit();
			args.RetVal = true;
		}

		#endregion

		#region Text Entry handlers

		public void OnLowDegreesChanged(object o, EventArgs args) {
			lowTemp = floatingPointVerify(LowDegrees, lowTemp);
			dWriteLine("lowTemp to : " + lowTemp.ToString());
		}

		public void OnMidDegreesChanged(object o, EventArgs args) {
			midTemp = floatingPointVerify(MidDegrees, midTemp);
			dWriteLine("midTemp to : " + midTemp.ToString());
		}

		public void OnHighDegreesChanged(object o, EventArgs args) {
			highTemp = floatingPointVerify(HighDegrees, highTemp);
			dWriteLine("highTemp to : " + highTemp.ToString());
		}

		public void OnLowOhmsChanged(object o, EventArgs args) {
			lowRes = floatingPointVerify(LowOhms, lowRes);
			dWriteLine("lowRes to : " + lowRes.ToString());
		}

		public void OnMidOhmsChanged(object o, EventArgs args) {
			midRes = floatingPointVerify(MidOhms, midRes);
			dWriteLine("midRes to : " + midRes.ToString());
		}

		public void OnHighOhmsChanged(object o, EventArgs args) {
			highRes = floatingPointVerify(HighOhms, highRes);
			dWriteLine("highRes to : " + highRes.ToString());
		}

		public void OnBiasOhmsChanged(object o, EventArgs args) {
			biasRes = floatingPointVerify(BiasOhms, biasRes);
			dWriteLine("biasRes to : " + biasRes.ToString());
		}

		public void OnElementsPerLineChanged(object o, EventArgs args) {
			elementsPerLine = integerVerify(ElementsPerLineEntry, elementsPerLine);
			dWriteLine("elementsPerLine to : " + elementsPerLine.ToString());
		}

		#endregion

		#region Radio Button handlers

		public void OnCelciusInToggled(object o, EventArgs args) {
			if (CelciusIn.Active) {
				inputTempScale = TempScale.Celcius;
				dWriteLine("CelciusIn to : " + inputTempScale.ToString());
			}
		}

		public void OnKelvinInToggled(object o, EventArgs args) {
			if (KelvinIn.Active) {
				inputTempScale = TempScale.Kelvin;
				dWriteLine("KelvinIn to : " + inputTempScale.ToString());
			}
		}

		public void OnFahrenheitInToggled(object o, EventArgs args) {
			if (FahrenheitIn.Active) {
				inputTempScale = TempScale.Fahrenheit;
				dWriteLine("FahrenheitIn to : " + inputTempScale.ToString());
			}
		}

		public void OnCelciusOutToggled(object o, EventArgs args) {
			if (CelciusOut.Active) {
				outputTempScale = TempScale.Celcius;
				dWriteLine("CelciusOut to : " + outputTempScale.ToString());
			}
		}

		public void OnKelvinOutToggled(object o, EventArgs args) {
			if (KelvinOut.Active) {
				outputTempScale = TempScale.Kelvin;
				dWriteLine("KelvinOut to : " + outputTempScale.ToString());
			}
		}

		public void OnFahrenheitOutToggled(object o, EventArgs args) {
			if (FahrenheitOut.Active) {
				outputTempScale = TempScale.Fahrenheit;
				dWriteLine("FahrenheitOut to : " + outputTempScale.ToString());
			}
		}

		#endregion

		#region Menu item handlers

		public void OnSaveMenuItemActivated(object o, EventArgs args)
		{
			Gtk.FileChooserDialog FCD = new Gtk.FileChooserDialog("Save...", MainWindow, FileChooserAction.Save, "Cancel", ResponseType.Cancel, "Save", ResponseType.Accept);
			FCD.CurrentName = FileNameEntry.Text;
			FCD.DoOverwriteConfirmation = true;

			int Response = FCD.Run();
			FCD.Hide();
			
			// TODO wrap this in try catch block to handle FS errors!!
			if (Response == (int)ResponseType.Accept)
			{
				FileStream file = new FileStream(FCD.Filename, FileMode.OpenOrCreate, FileAccess.Write);

				/* Clear the file pre writing or we end up with weird output. */
				file.SetLength(0);
				file.Flush();

				StreamWriter writer = new StreamWriter(file);

				calculateSHCoefficients();

				/* Write comments out to the file before the array. */
				writer.Write(CommentView.Buffer.Text + "\n");
				
				// Write values being used out to another commend block after the specified one!
				writer.Write("/* Generated by FreeTherm " + VERSION + " using the following parameters:\n");
				writer.Write(" *\n");
				writer.Write(" * Bias Resistor:\n");
				writer.Write(" * Value: " + biasRes + "\n");
				writer.Write(" *\n");
				writer.Write(" * Sensor Sample Points:\n");
				writer.Write(" * Temp Low  : " + lowTemp  + "\n");
				writer.Write(" * Temp Mid  : " + midTemp  + "\n");
				writer.Write(" * Temp High : " + highTemp + "\n");
				writer.Write(" * Res Low   : " + lowRes   + "\n");
				writer.Write(" * Res Mid   : " + midRes   + "\n");
				writer.Write(" * Res High  : " + highRes  + "\n");
				writer.Write(" *\n");
				writer.Write(" * Temp Units:\n");
				writer.Write(" * Input Temp Scale: " + inputTempScale + "\n");
				writer.Write(" * Output Temp Scale: " + outputTempScale + "\n");
				writer.Write(" *\n");
				writer.Write(" */\n\n"); // Close comment block
				
				/* First line of the code itself is composed of different parts. Element count
				 * should be included as verification that the array is correctly sized. */ 
				writer.WriteLine(KeyWords + DataType + ArrayNameEntry.Text + "[" + Elements.ToString() + "] = {");

				/* First value is always max due to maths involved. */
				writer.Write(Ceiling.ToString(DataFormat));

				/* Loop is one short because the first one will always be NAN and is a special case. */
				for (int loop = 1; loop < Elements; loop++)
				{
					/* Calculate the resistance. */
					double res = biasRes / ( ( 1.0 / ( (double) loop / (double) Elements) ) - 1.0 );
					
					/* And the temperature */
					double y = Math.Log(res);
					double yc = Math.Pow(y, 3);
					double temp = 1 / (A + B * y + C * yc);

//					if ((loop - 1) % 128 == 0) {
//						dWriteLine("Input temp is : " + temp.ToString());
//					}
					
					/* Convert to output scale if required */
					if (outputTempScale == TempScale.Celcius) {
						temp = temp - KelvinOffset;
					} else if (outputTempScale == TempScale.Fahrenheit) {
						temp = (((temp - KelvinOffset) * 9) / 5) + FahrenheitOffset; 
					} else if (outputTempScale == TempScale.Kelvin) {
						// Do nothing, default is Kelvin
					} else {
						Console.WriteLine("This line should never be printed!"); // To alert the user to the issue
						writer.WriteLine("This line should never be printed!"); // To break the file for compilation
						// return; uncomment once finally block installed. // To fail fast
					}
						
//					if ((loop - 1) % 128 == 0) {
//						dWriteLine("Output temp is : " + temp.ToString());
//					}
					
					/* Multiply and Shift. */
					temp *= outputFactor;
					temp += outputOffset;
					
//					if ((loop - 1) % 128 == 0) {
//						dWriteLine("Translated temp is : " + temp.ToString());
//					}
					
					/* Cap the output at the ceiling and floor values. */
					if (temp > Ceiling) {
						temp = Ceiling;
					} else if (temp < Floor) {
						temp = Floor;
					}

//					if ((loop - 1) % 128 == 0) {
//						dWriteLine("RangeLimited temp is : " + temp.ToString());
//					}
					
					/* Decide whether to hit enter or space out. */
					string filler = " ";
					if (loop % elementsPerLine == 0) {
						filler = EOL;
						
					}
					
					/* Write the comma, newline, and value out to the file. */
					writer.Write("," + filler + temp.ToString(DataFormat));
				}

				/* Close the array. */
				writer.WriteLine("\n};");
				
				/* Tidy up our file writer. TODO this should be in a finally block with appropriate null checks etc */
				writer.Flush();
				writer.Close();
			}
			FCD.Destroy();
		}
		
		public void OnQuitMenuItemActivated(object o, EventArgs args) {
			Application.Quit();
		}
		
		public void OnAboutMenuItemActivated(object o, EventArgs args) {
			try {
				/* Load the window from the embedded glade file. */
				Glade.XML AboutXML = new Glade.XML(null, "FreeTherm.glade", "AboutFreeThermDialog", null);
				AboutXML.Autoconnect(this);
				
				if(AboutFreeThermDialog == null) {
					Console.WriteLine("Why is AboutFreeThermDialog null?");
				} else {
					AboutFreeThermDialog.Logo = new Gdk.Pixbuf(null, "diy.php.png");	// Load the embedded resource into the dialog.
					AboutFreeThermDialog.TransientFor = MainWindow;
					AboutFreeThermDialog.Run();
					AboutFreeThermDialog.Destroy();
				}
			} catch(Exception e) {
				Console.WriteLine("About dialog exception : " + e.Message + "/nAbout dialog stacktrace : " + e.StackTrace);
			}
        }

        #endregion

        // Common functions used by buttons and menu items
	}
}

